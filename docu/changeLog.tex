\documentclass{article}

\usepackage[utf8]{inputenc}

\begin{document}

\begin{titlepage}
\author{Gennadi Heimann} 
\title{Change Log} 
\date{29.12.2017} 
\maketitle
\end{titlepage}

\section{v0.0.1}
@created on     14.11.2017\\
@finished on   21.12.2017\\

Der nächste Schritt wird erst freigegeben, wenn alle Abhängigkeiten 
der Komponenten geprüft sind. Beim Prüfen von der ausgewählte 
Komponente wird auch die SelectionCriterium geprüft, wieviel Komponenten 
in dem Schritt ausgewählt werden können.

Die ausgewählte Komponente wird in der CurrentConfig gesichert, damit das
SelectionCriterium bewertet weden kann.\\

\section{v0.0.2}

@created on     4.12.2017\\
@finished on   19.03.2018\\
Die aktuelle Konfiguration behält gesamte Information über die hinzugefügte
Komponente. Dazu gehören alle Abhängigkeiten und Einschränkungen und
Komponente mit $<exclude>$ Markierung.\\
\\
@created on 18.12.2017\\
@finished on 19.03.2018\\
Bei dem Abschluss der Konfiguration muss auf die Konsistenz den letzten
Schritte geachtet werden. Es kann sein, dass in einem Schritt paar Komponente
ohne weiteren Schritt und paar mit weiterem Schritt haben. (siehe
szenario\_3)\\
\\
@created on 20.12.2017\\
@finished on 19.03.2018\\
Bei der Auswahl der gleichen Komponente innerhalb eines Schrittes muss 
diese Änderung erkannt werden und eine Info an den Webclient gesendet.\\
\\
@created on 21.12.2017\\
@finished on 21.12.2017\\
Zu der $<ComponentOut>$ die $<componentId>$ und $<stepId>$ Parameter bei
allen Status hinzuf\"ugen.\\
\\
@created on 21.12.2017\\
@finished on 19.03.2018\\
Abw\"ahlen der Komponente muss auch implimentiert werden. Die Komponente wird
auch aus der $<CurrentConfig>$ entfernt.\\
\\

\section{v0.0.5}

\noindent \textbf{@created on 16.11.2018}\\
\textbf{@finished on} \\
\textbf{@name Auflösung der Abhängigkeit zwischen Komponenten}\\

\noindent Implementierung von $<exclude>$ und $<require>$ Abhängigkeiten zwischen der externen Komponenten.
Es wird zwischen verschiedene Arten der Auflösung der Abhängigkeiten $<StrategyOfDependencyResolver>$ gesehen.
Die Einstellung zu der Auflösung der Abhängigkeit wird direkt in dem $<Dependency>$ Edge gehalten.

\begin{itemize}
    \item $<auto>$ $\Rightarrow$ Die Abhängigkeit wird automatisch aufgelöst.
    \item $<selectableDecision>$ $\Rightarrow$ Die Abhängigkeit durch 
    die aktive Entscheidung der Anwender aufgelöst. 
\end{itemize}

\noindent\underline{Interne Komponente} sind die Komponente die einem Schritt gehören.\\
\underline{Externe Komponente} sind die Komponente die verschiedenen Schritten gehören.\\

\noindent Bei der $<exclude>$ Abhängigkeit werde zwischen ausschließende und ausgeschlossenen 
Komponente unterschieden.\\
C1 - ausschließende Komponente\\
C2 - ausgeschlossene Komponent\\

Aussage 1: Komponente C1 schließt die Komponente C2 aus der Konfiguration aus. Das bedeutet, dass
der Komponente C2 darf nicht ausgewählt werden, wenn die Komponente C1 davor ausgewählt war. Das ist 
eine $<forward>$ Auflösung der Abhängigkeit.\\

Aussage 2: Komponente C1 schließt die Komponente C2 aus der Konfiguration aus. 
Aber im Gegensatz zu der Aussage 1 wird die Komponente C2 vor C1 ausgewählt war. Das bedeutet, 
dass die Komponente C2 aus der Konfiguration entfernt wird und rekursiv nach 
anderen Abhängigkeiten gesucht und aufgelöst. Diese Auflösung wird als $<reverse>$ Auflösung 
der Abhängigkeiten genannt.\\\\

Bei der $<reverse>$ Auflösung muss beachtet werden, wenn die ausgeschlossene Komponente einzige 
ausgewählte Komponente in dem Schritt ist. (muss überdacht werden) In dieser Situation wird die 
ausgeschlossene Komponente aus der aktueller Konfiguration entfernt werden.  


\noindent\textbf{In dieser Version wird nur automatische Auflösung der Abhängigkeit implementiert.}\\

\noindent\textbf{@created on 23.11.2018}\\
\textbf{@finished on }\\
\textbf{@name Arten des Konfigurationsverlaufes}\\

\noindent Erkennung der Konfigurationsverlauf.\\
Es gibt zwei Konfigurationverläufe: 

\begin{itemize}
	\item $<configurationCourse=sequence>$
	\item $<configurationCourse=substitute>$
\end{itemize}
\noindent Der Konfigurationsverlauf wird in dem Vertex Config abgespeichert. \\

\noindent \textbf{@created on 23.11.2018}\\
\textbf{@finished on }\\
\textbf{@name}\\

\noindent Die Abhängigkeiten zu der aktuelle Konfiguration hinzufügen.\\

\noindent \textbf{@created on 23.11.2018}\\
\textbf{@finished on }\\\\
Die Logik Ausdenken mit der die Info zu der ausgewählte Komponente veranschaulicht.\\

\subsection{v0.0.6}

\textbf{@created on 13.12.2017}\\
\textbf{@finished on} \\
\textbf{@name }\\

\noindent Jeder Schritt in dem Konfigurator kann eine Abhängigkeit zu dem Schritt oder
Komponente haben. Das bedeutet, dass geladene Schritt eine Komponente oder einen
Schritt ausschließen oder fordern kann. Die Implementierung der Abhängigkeit von und zu
dem Schritt wird in dieser Version implementiert.\\

\noindent \textbf{@created on 18.01.2019}\\
\textbf{@finished on 06.02.2019}\\\\

Implementierung von Warnungen und Information und Fehler Objekten.

\noindent \textbf{@created on 06.02.2019}\\
\textbf{@finished on}\\\\
Die Texte für Info, Warning werden aus dem DB ausgelesen, da sie über Admin angepasst werden müssen.

Visualisierung der Abhängigkeit (behavior)



\end{document}

























